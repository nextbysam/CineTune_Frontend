import { NextRequest, NextResponse } from "next/server";
import { promises as fs } from "fs";
import path from "path";
import { jobManager } from "@/lib/job-manager";
import { nanoid } from "nanoid";

// Handle CORS preflight request
export async function OPTIONS() {
	return new NextResponse(null, {
		status: 200,
		headers: {
			"Access-Control-Allow-Origin": "*",
			"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
			"Access-Control-Allow-Headers": "Content-Type, Authorization",
		},
	});
}

export async function GET(
	request: NextRequest,
	{ params }: { params: Promise<{ jobId: string }> },
) {
	const requestId = nanoid().slice(0, 8);
	const { jobId } = await params;

	console.log(`üîµ [${requestId}] GET /api/captions/${jobId} - Request started`);

	try {
		console.log(`üîµ [${requestId}] Retrieving captions for job: ${jobId}`);

		// Check if job exists
		const job = jobManager.getJob(jobId);
		console.log(
			`üîµ [${requestId}] Job lookup result:`,
			job ? "Found" : "Not found",
		);

		if (!job) {
			console.error(`‚ùå [${requestId}] Job not found: ${jobId}`);
			return NextResponse.json(
				{
					success: false,
					error: "Job not found",
					message: `No job found with ID: ${jobId}`,
				},
				{ status: 404 },
			);
		}

		console.log(`üîµ [${requestId}] Job status: ${job.status}`);

		// Return job status and captions if available
		const response: any = {
			success: true,
			jobId: jobId,
			status: job.status,
		};

		if (job.status === "completed" && job.captions) {
			console.log(
				`‚úÖ [${requestId}] Job completed, captions available:`,
				job.captions.length,
				"captions",
			);
			response.captions = job.captions;
			response.message = "Captions generated successfully";

			// TODO: Also try to read from captions_for_remotion.json file
			// This would be the actual file generated by the Python script
			try {
				console.log(
					`üîµ [${requestId}] Attempting to read captions from file...`,
				);
				const captionsFilePath = path.join(
					process.cwd(),
					"captions_for_remotion.json",
				);
				console.log(`üîµ [${requestId}] File path: ${captionsFilePath}`);

				const captionsFileContent = await fs.readFile(
					captionsFilePath,
					"utf-8",
				);
				console.log(
					`‚úÖ [${requestId}] File read successfully, size: ${captionsFileContent.length} bytes`,
				);

				const fileCaptions = JSON.parse(captionsFileContent);
				console.log(`üîµ [${requestId}] Parsed file captions:`, fileCaptions);

				// Use file captions if available, otherwise use memory captions
				response.captions = fileCaptions.captions || job.captions;
				response.source = "file";
				console.log(
					`‚úÖ [${requestId}] Using captions from file, count: ${response.captions.length}`,
				);
			} catch (fileError) {
				console.log(
					`‚ö†Ô∏è [${requestId}] No captions file found, using memory captions:`,
					fileError,
				);
				response.source = "memory";
				console.log(
					`üîµ [${requestId}] Using captions from memory, count: ${response.captions.length}`,
				);
			}
		} else if (job.status === "failed") {
			console.error(`‚ùå [${requestId}] Job failed:`, job.error);
			response.error = job.error;
			response.message = "Caption generation failed";
		} else if (job.status === "processing") {
			console.log(`‚è≥ [${requestId}] Job still processing...`);
			response.message = "Video is still being processed";
		}

		console.log(`‚úÖ [${requestId}] Returning response:`, {
			success: response.success,
			status: response.status,
			captionsCount: response.captions ? response.captions.length : 0,
			source: response.source,
			message: response.message,
		});

		return NextResponse.json(response, {
			headers: {
				"Access-Control-Allow-Origin": "*",
				"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
				"Access-Control-Allow-Headers": "Content-Type, Authorization",
			},
		});
	} catch (error) {
		console.error(`‚ùå [${requestId}] Error retrieving captions:`, error);

		return NextResponse.json(
			{
				success: false,
				error: "Failed to retrieve captions",
				message: error instanceof Error ? error.message : "Unknown error",
			},
			{
				status: 500,
				headers: {
					"Access-Control-Allow-Origin": "*",
					"Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, OPTIONS",
					"Access-Control-Allow-Headers": "Content-Type, Authorization",
				},
			},
		);
	}
}

// Optional: Add DELETE method to clean up completed jobs
export async function DELETE(
	request: NextRequest,
	{ params }: { params: Promise<{ jobId: string }> },
) {
	try {
		const { jobId } = await params;

		const deleted = jobManager.deleteJob(jobId);

		return NextResponse.json({
			success: true,
			message: deleted ? "Job deleted successfully" : "Job not found",
			jobId: jobId,
		});
	} catch (error) {
		console.error("Error deleting job:", error);

		return NextResponse.json(
			{
				success: false,
				error: "Failed to delete job",
				message: error instanceof Error ? error.message : "Unknown error",
			},
			{ status: 500 },
		);
	}
}
